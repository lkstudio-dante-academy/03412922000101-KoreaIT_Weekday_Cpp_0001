#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 람다 (Lambda) 란?
* - 이름이 존재하지 않는 함수를 의미한다. (+ 즉, 람다는 일반적인 함수와 달리 재사용을 위해
* 사용되는 함수가 아니라는 것을 알 수 있다.)
*
* 람다는 다른 함수 내부에 구현 되기 때문에 내장 함수라고도 불리며 람다를 감싸고 있는 외부 함수에
* 선언 된 지역 변수에 접근하는 것이 가능하다. (+ 즉, 람다는 외부 함수의 일부분으로 취급 된다는 것을
* 알 수 있다.)
*
* C++ 람다 구현 방법
* - 캡처절 + 매개 변수절 + 반환형 + 람다 몸체
*
* Ex)
* auto oLambda = [](int a_nValA, int a_nValB) -> void
* {
*		// Do Something
* }
*
* oLambda(10, 20);
*
* 위와 같이 구현 된 람다는 변수에 할당해서 호출하는 것이 가능하며 이때 변수의 자료형은
* auto 키워드를 명시해야한다. (+ 즉, 람다의 자료형은 C++ 컴파일러만 알고 있기 때문에
* auto 키워드를 명시해서 C++ 컴파일러가 변수의 자료형을 결정하도록 해야한다는 것을 알 수 있다.)
*
* 캡처절이란?
* - 람다 내부에서 접근 할 외부 함수의 지역 변수를 캡처하는 절을 의미한다. (+ 즉, 캡처절을 활용하면
* 람다 내부에서 외부 함수의 지역 변수에 접근하는 것이 가능하다.)
*
* 캡처는 값 캡처와 참조 캡처가 존재하며 값 캡처는 외부 함수의 지역 변수의 사본을 람다 내부에
* 선언한다. (+ 즉, 캡처 된 변수를 수정해도 원본에는 영향을 미치지 않는다는 것을 알 수 있다.)
*
* 반면 참조 캡처는 외부 함수의 지역 변수의 레퍼런스를 람다 내부에 선언하는 차이점이 존재한다. (+ 즉,
* 레퍼런스를 통해 원본 변수를 수정 할 수 있다는 것을 의미한다.)
*
* Ex)
* int nValA = 0;
* int nValB = 0;
*
* auto oLambda = [nValA, &nValB](void) -> void
* {
*		// Do Something
* };
*
* 위와 같이 캡처절에 외부 함수의 지역 변수를 명시하면 값으로 캡처가 되며 & (레퍼런스 연산자) 를
* 명시하면 참조로 캡처가 된다.
*
* 단, 람다 내부에서 레퍼런스를 통해 원본 변수에 접근하는 시점에 원본 변수가 제거 될 가능성이
* 있다면 절대로 참조 캡처를 사용하면 안된다. (+ 즉, 잘못된 메모리 접근에 의해 프로그램이
* 오작동 한다는 것을 알 수 있다.)
*
* Ex)
* std::function<void(void)> SomeFunc(int a_nVal)
* {
*		return [&a_nVal](void) -> void
*		{
*			std::cout << a_nVal << std::endl;
*		};
* }
*
* auto oLambda = SomeFunc(10);
* oLambda();							<- 잘못된 메모리 참조
*
* 위와 같이 람다 함수 내부에 작성 된 명령문이 실행 되는 시점에는 외부 함수에 선언 된 a_nVal 는
* 메모리에서 제거 되었기 때문에 잘못된 메모리 참조에 의해 프로그램이 오작동 한다는 것을 알 수 있다.)
*/
namespace E01Example
{
	/** Example 7 */
	int E01Example_07(int argc, char* args[]);
}
