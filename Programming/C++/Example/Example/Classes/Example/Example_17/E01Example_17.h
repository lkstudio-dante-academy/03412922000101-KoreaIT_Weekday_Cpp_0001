#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 템플릿 (Template) 이란?
* - 자료형을 명시하지 않고 함수 or 클래스를 정의 할 수 있는 기능을 의미한다. (+ 즉, 
* 템플릿을 활용하면 자료형이 다른 이유로 중복 되는 함수나 클래스를 정의 할 필요가 없다는 것을 
* 알 수 있다.)
* 
* C++ 은 강력 형식 언어 (Strong Type Language) 이기 때문에 데이터를 연산 할 때는 항상 자료형을 
* 명시 할 필요가 있다.
* 
* 따라서 자료형이 서로 다르다면 동일한 명령문을 수행하는 함수나 클래스를 중복으로 정의해야되는 
* 단점이 존재한다.
* 
* 이때 템플릿을 활용하면 동일한 명령문을 수행하는 함수나 클래스를 중복으로 정의 할 필요가 없어진다. 
* (+ 즉, 템플릿은 자료형을 명시하지 않고 함수나 클래스를 정의하기 때문에 중복 된 명령문을 
* 작성하지 않아도 된다는 것을 의미한다.)
* 
* C++ 함수 템플릿 정의 방법
* - 템플릿 형식 인자 + 반환형 + 함수 이름 + 매개 변수 + 함수 몸체
* 
* Ex)
* template<typename T>
* void SomeFunc(T a_tValA, T a_tValB)
* {
*		// Do Something
* }
* 
* SomeFunc(10, 20);
* SomeFunc<std::string>("A", "B");
* 
* 위와 같이 템플릿을 활용하면 동일한 명령문을 여러 자료형에 재사용하는 것이 가능하다.
* 
* 단, C++ 은 데이터를 연산하기 위해서 반드시 자료형이 필요하며 함수 템플릿에서 자료형의 역할을 
* 템플릿 형식 인자가 수행한다. (+ 즉, 템플릿 형식 인자는 함수 템플릿에서 사용되는 
* 임시 자료형이라는 것을 알 수 있다.)
* 
* 함수 템플릿은 함수가 호출 될때 템플릿 형식 인자를 실제 자료형으로 치환 시켜서 동작하며 
* 이때 템플릿 형식 인자를 치환시킬 자료형은 함수의 매개 변수에 전달 되는 입력 데이터를 기반으로 
* C++ 컴파일러에 의해 자동으로 결정된다.
* 
* 만약 템플릿 형식 인자의 자료형을 명시적으로 지정하고 싶다면 <자료형> 과 같이 호출 할 함수 이름에 
* 자료형을 직접 명시하면 된다.
*/
namespace E01Example
{
	/** Example 17 */
	int E01Example_17(int argc, char* args[]);
}
