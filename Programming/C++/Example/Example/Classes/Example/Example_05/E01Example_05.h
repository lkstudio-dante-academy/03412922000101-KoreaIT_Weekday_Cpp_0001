#pragma once

#include "../../Global/Define/KDefine+Global.h"

/*
* 스마트 포인터 (Smart Pointer) 란?
* - 동적 할당 된 메모리를 자동으로 관리해주는 포인터를 의미한다. (+ 즉, 스마트 포인터를 활용하면
* new 키워드를 통해 힙 영역에 할당 된 메모리를 직접 관리 할 필요가 없다는 것을 알 수 있다.)
*
* C++ 은 동적 할당 된 메모리를 사용자 (프로그래머) 가 직접 관리해야하는 언어이기 때문에
* 사용 완료 된 메모리는 직접 해제해줘야한다.
*
* 따라서 해당 과정에서 많은 실수 (+ Ex. 메모리 릭 등등...) 가 발생하기 때문에
* C++ 은 동적 할당 된 메모리를 좀 더 쉽게 관리 할 수 있는 스마트 포인터를 제공한다.
*
* C++ 스마트 포인터 종류
* - auto_ptr			<- 소유권 이전 방식으로 동작
* - unique_ptr			<- 소유권 이전 방식으로 동작 (+ C++ 11 버전 이후부터 사용 가능)
* - shared_ptr			<- 레퍼런스 카운팅 방식으로 동작 (+ C++ 11 버전 이후부터 사용 가능)
* - weak_ptr			<- shared_ptr 의 순환 참조 문제 해결을 위해 사용
*
* 위와 같이 스마트 포인터는 여러 종류가 존재하며 스마트 포인터에 따라 메모리를 관리하는 방식이
* 다르다. (+ 즉, 스마트 포인터는 소유권 이전 방식 or 레퍼런스 카운팅 방식으로 메모리를
* 관리 한다는 것을 알 수 있다.)
*
* auto_ptr 이란?
* - 소유권 이전 방식으로 메모리를 관리하는 스마트 포인터를 의미한다.
*
* auto_ptr 은 C++ 11 버전 이전부터 지원되던 스마트 포인터이지만 설계 결함으로 인해
* 사용 되지 않는 스마트 포인터이다.
*
* 따라서 C++ 17 버전 이후부터는 제거 되었으며 auto_ptr 대신에 unique_ptr 을 사용하는 것을
* 추천한다. (+ 즉, auto_ptr 은 현재 비권장 상태이며 C++ 17 버전 이후부터는 지원하지 않는다.)
*
* Ex)
* std::auto_ptr<int> oPtrA(new int(0));
* std::auto_ptr<int> oPtrB;
*
* oPtrB = oPtrA;			<- 소유권 이전
*
* 위와 같이 auto_ptr 은 = (할당 연산자) 를 통해 소유권을 이전하는 것이 가능하다.
*
* unique_ptr 이란?
* - C++ 11 버전 이후부터 사용 가능한 스마트 포인터로서 소유권 이전 방식으로 메모리를 관리하는
* 스마트 포인터를 의미한다.
*
* unique_ptr 은 auto_ptr 의 설계 결함을 보완 한 스마트 포인터로서 이동 시멘틱을 통해 소유권을
* 이전하는 차이점이 존재한다. (+ 즉, unique_ptr 은 복사와 이동 시멘틱 구분이 명확하다는 것을
* 알 수 있다.)
*
* Ex)
* std::unique_ptr<int> oPtrA(new int(0));
* std::unique_ptr<int> oPtrB;
*
* oPtrB = std::move(oPtrA);			<- 소유권 이전
*
* 위와 같이 unique_ptr 은 move 함수를 통해 소유권을 이전하는 것이 가능하다.
*/
namespace E01Example
{
	/** Example 5 */
	int E01Example_05(int argc, char* args[]);
}