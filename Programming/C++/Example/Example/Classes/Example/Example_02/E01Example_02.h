#pragma once

#include "../../../Classes/Global/Define/KDefine+Global.h"

/*
* 레퍼런스 (Reference) 란?
* - 기존 변수에 새로운 이름을 부여하는 것을 의미한다. (+ 즉, 레퍼런스를 활용하면
* 기존 변수의 이름을 통하지 않고 해당 변수를 제어하는 것이 가능하다.)
* 
* 레퍼런스는 기존 변수에 새로운 이름을 부여하는 것이기 때문에 단독으로 사용하는 것은 불가능하며
* 레퍼런스를 사용하기 전에 반드시 새로운 이름을 부여 할 변수가 선언 되어있어야한다.
* 
* C++ 레퍼런스 선언 방법
* - 자료형 + 레퍼런스 연산자 + 레퍼런스 이름
* 
* Ex)
* int nVal = 0;
* int& rnVal = nVal;						<- nVal 변수에 rnVal 이름 부여
* 
* rnVal = 10;
* std::cout << rnVal << std::endl;			<- "10" 출력
* 
* 위와 같이 레퍼런스를 활용하면 기존 변수에 새로운 이름을 부여하는 것이 가능하다. (+ 즉, 
* 선언 된 레퍼런스를 통해 기존 변수를 제어하는 것이 가능하다.)
* 
* 단, 레퍼런스는 초기화 시점에만 기존 변수에 새로운 이름을 부여하는 것이 가능하기 때문에
* 레퍼런스를 선언 할 때는 반드시 특정 변수를 할당해줘야한다.
* 
* C++ 레퍼런스 동작 원리
* - C++ 레퍼런스는 내부적으로 포인터를 활용해서 구현 된다. (+ 즉, 레퍼런스는 포인터를 통해
* 구현 되기 때문에 레퍼런스를 통해 기존 변수를 제어 할 수 있다는 것을 알 수 있다.)
* 
* Ex)
* int nVal = 0;
* int& rnVal = nVal;			<- "int* const rnVal = &nVal" 과 같은 의미
* 
* rnVal = 10;					<- "*rnVal = 10" 과 같은 의미
* 
* 위와 같이 레퍼런스를 사용하면 해당 명령문은 C++ 컴파일러에 의해 포인터를 사용하는 명령문으로
* 변경 된다는 것을 알 수 있다.
*/
namespace E01Example
{
	/** Example 2 */
	int E01Example_02(int argc, char* args[]);
}
